{
  "version": 3,
  "sources": ["../lib/validate.js", "../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isObject = require( '@stdlib/assert-is-plain-object' );\nvar hasOwnProp = require( '@stdlib/assert-has-own-property' );\nvar contains = require( '@stdlib/array-base-assert-contains' );\nvar join = require( '@stdlib/array-base-join' );\nvar resolveStr = require( '@stdlib/ndarray-base-dtype-resolve-str' );\nvar format = require( '@stdlib/string-format' );\n\n\n// MAIN //\n\n/**\n* Validates function options.\n*\n* @private\n* @param {Object} opts - destination object\n* @param {Array<string>} dtypes - list of supported output data types\n* @param {Options} options - function options\n* @param {*} [options.dtype] - array data type\n* @param {string} [options.order] - memory layout (either row-major or column-major)\n* @param {string} [options.mode] - specifies how to handle indices which exceed array dimensions\n* @param {ArrayLikeObject<string>} [options.submode] - specifies how to handle subscripts which exceed array dimensions on a per dimension basis\n* @param {boolean} [options.readonly] - boolean indicating whether an array should be read-only\n* @returns {(Error|null)} null or an error object\n*\n* @example\n* var opts = {};\n* var dtypes = [ 'float64', 'float32', 'generic' ];\n*\n* var options = {\n*     'dtype': 'float64'\n* };\n* var err = validate( opts, dtypes, options );\n* if ( err ) {\n*     throw err;\n* }\n*/\nfunction validate( opts, dtypes, options ) {\n\tif ( !isObject( options ) ) {\n\t\treturn new TypeError( format( 'invalid argument. Options argument must be an object. Value: `%s`.', options ) );\n\t}\n\tif ( hasOwnProp( options, 'dtype' ) ) {\n\t\topts.dtype = resolveStr( options.dtype );\n\t\tif ( !contains( dtypes, opts.dtype ) ) {\n\t\t\treturn new TypeError( format( 'invalid option. `%s` option must be one of the following: \"%s\". Option: `%s`.', 'dtype', join( dtypes, '\", \"' ), options.dtype ) );\n\t\t}\n\t}\n\t// Pass-through options...\n\tif ( hasOwnProp( options, 'order' ) ) {\n\t\topts.order = options.order;\n\t}\n\tif ( hasOwnProp( options, 'mode' ) ) {\n\t\topts.mode = options.mode;\n\t}\n\tif ( hasOwnProp( options, 'submode' ) ) {\n\t\topts.submode = options.submode;\n\t}\n\tif ( hasOwnProp( options, 'readonly' ) ) {\n\t\topts.readonly = options.readonly;\n\t}\n\treturn null;\n}\n\n\n// EXPORTS //\n\nmodule.exports = validate;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-restricted-syntax, no-invalid-this */\n\n'use strict';\n\n// MODULES //\n\nvar setReadOnly = require( '@stdlib/utils-define-nonenumerable-read-only-property' );\nvar isNonNegativeIntegerArray = require( '@stdlib/assert-is-nonnegative-integer-array' ).primitives;\nvar isEmptyCollection = require( '@stdlib/assert-is-empty-collection' );\nvar isndarrayLike = require( '@stdlib/assert-is-ndarray-like' );\nvar isNumber = require( '@stdlib/assert-is-number' ).isPrimitive;\nvar isFunction = require( '@stdlib/assert-is-function' );\nvar isComplexLike = require( '@stdlib/assert-is-complex-like' );\nvar isPlainObject = require( '@stdlib/assert-is-plain-object' );\nvar isObject = require( '@stdlib/assert-is-object' );\nvar isCollection = require( '@stdlib/assert-is-collection' );\nvar isDataType = require( '@stdlib/ndarray-base-assert-is-data-type' );\nvar isEqualDataType = require( '@stdlib/ndarray-base-assert-is-equal-data-type' );\nvar isOutputDataTypePolicy = require( '@stdlib/ndarray-base-assert-is-output-data-type-policy' );\nvar isReadOnly = require( '@stdlib/ndarray-base-assert-is-read-only' );\nvar isOrder = require( '@stdlib/ndarray-base-assert-is-order' );\nvar hasOwnProp = require( '@stdlib/assert-has-own-property' );\nvar contains = require( '@stdlib/array-base-assert-contains' );\nvar filledBy = require( '@stdlib/array-base-filled-by' );\nvar everyBy = require( '@stdlib/array-base-every-by' );\nvar join = require( '@stdlib/array-base-join' );\nvar copy = require( '@stdlib/array-base-copy' );\nvar nullaryStrided = require( '@stdlib/strided-base-nullary' );\nvar binary = require( '@stdlib/ndarray-base-binary' );\nvar broadcast = require( '@stdlib/ndarray-base-maybe-broadcast-array' );\nvar broadcastScalar = require( '@stdlib/ndarray-base-broadcast-scalar' );\nvar shape2strides = require( '@stdlib/ndarray-base-shape2strides' );\nvar dtypes2strings = require( '@stdlib/ndarray-base-dtypes2strings' );\nvar resolveStr = require( '@stdlib/ndarray-base-dtype-resolve-str' );\nvar binaryOutputDataType = require( '@stdlib/ndarray-base-binary-output-dtype' );\nvar numel = require( '@stdlib/ndarray-base-numel' );\nvar buffer = require( '@stdlib/ndarray-base-buffer' );\nvar getShape = require( '@stdlib/ndarray-shape' );\nvar getDType = require( '@stdlib/ndarray-dtype' );\nvar getOrder = require( '@stdlib/ndarray-order' );\nvar ndims = require( '@stdlib/ndarray-ndims' );\nvar ndarray = require( '@stdlib/ndarray-ctor' );\nvar defaults = require( '@stdlib/ndarray-defaults' );\nvar isAccessorArray = require( '@stdlib/array-base-assert-is-accessor-array' );\nvar accessorSetter = require( '@stdlib/array-base-accessor-setter' );\nvar setter = require( '@stdlib/array-base-setter' );\nvar format = require( '@stdlib/string-format' );\nvar validate = require( './validate.js' );\n\n\n// VARIABLES //\n\nvar ORDINALS = [ 'First', 'Second', 'Third' ];\n\n\n// FUNCTIONS //\n\n/**\n* Performs an initial scan of a list of parameters.\n*\n* @private\n* @param {Array} params - list of parameters\n* @returns {Array} scan results\n*/\nfunction initialScan( params ) {\n\tvar out;\n\tvar p;\n\tvar o;\n\tvar i;\n\n\tout = [];\n\tfor ( i = 0; i < params.length; i++ ) {\n\t\tp = params[ i ];\n\t\to = {\n\t\t\t'scalar': true,\n\t\t\t'value': p,\n\t\t\t'dtype': '',\n\t\t\t'ndims': 0,\n\t\t\t'order': ''\n\t\t};\n\t\tif ( isNumber( p ) ) {\n\t\t\to.dtype = 'float64';\n\t\t} else if ( isComplexLike( p ) ) {\n\t\t\tif ( p.byteLength === 8 ) {\n\t\t\t\to.dtype = 'complex64';\n\t\t\t} else {\n\t\t\t\to.dtype = 'complex128';\n\t\t\t}\n\t\t} else if ( isndarrayLike( p ) ) {\n\t\t\to.scalar = false;\n\t\t\to.dtype = resolveStr( getDType( p ) );\n\t\t\to.ndims = ndims( p );\n\t\t\to.order = getOrder( p );\n\t\t} else {\n\t\t\to.dtype = 'generic';\n\t\t}\n\t\tout.push( o );\n\t}\n\treturn out;\n}\n\n/**\n* Checks whether all parameters are scalar compatible.\n*\n* ## Notes\n*\n* -   A parameter is scalar compatible if, and only if, the parameter value is either a zero-dimensional ndarray or already a scalar value.\n*\n* @private\n* @param {Array<Object>} params - list of parameter objects\n* @returns {boolean} boolean indicating whether all parameters are scalar compatible\n*/\nfunction isScalarCompatible( params ) {\n\tvar count;\n\tvar p;\n\tvar i;\n\n\tcount = 0;\n\tfor ( i = 0; i < params.length; i++ ) {\n\t\tp = params[ i ];\n\t\tif ( p.scalar || p.ndims === 0 ) {\n\t\t\tcount += 1;\n\t\t}\n\t}\n\treturn ( count === params.length );\n}\n\n/**\n* Converts a list of parameters to scalar values.\n*\n* ## Notes\n*\n* -   The function **mutates** the input array by updating parameter objects which do not already correspond to scalar parameter values.\n*\n* @private\n* @param {Array<Object>} params - list of parameter objects\n* @returns {Array<Object>} updated list\n*/\nfunction convertToScalars( params ) {\n\tvar p;\n\tvar i;\n\n\tfor ( i = 0; i < params.length; i++ ) {\n\t\tp = params[ i ];\n\t\tif ( p.scalar === false ) {\n\t\t\tp.scalar = true;\n\t\t\tp.value = p.value.get();\n\t\t\tp.ndims = 0;\n\t\t\tp.order = '';\n\t\t}\n\t}\n\treturn params;\n}\n\n/**\n* Resolves a common memory layout from a list of parameter objects.\n*\n* @private\n* @param {Array<Object>} params - list of parameter objects\n* @returns {string} memory layout\n*/\nfunction resolveOrder( params ) {\n\tvar p;\n\tvar i;\n\tfor ( i = 0; i < params.length; i++ ) {\n\t\tp = params[ i ];\n\n\t\t// For a binary parameter function, we simply return the layout of the first parameter having a layout, as there is no clear rationale for picking the layout of one parameter over another and picking the first one we find is as good a rationale as any other...\n\t\tif ( p.scalar === false ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn p.order;\n}\n\n/**\n* Broadcasts parameter values to an ndarray having a specified shape.\n*\n* ## Notes\n*\n* -   The function **mutates** the input array.\n*\n* @private\n* @param {NonNegativeIntegerArray} shape - array shape\n* @param {Array<Object>} params - list of parameter objects\n* @returns {Array<Object>} updated list\n*/\nfunction broadcastParameters( shape, params ) {\n\tvar ord;\n\tvar p;\n\tvar i;\n\n\tord = resolveOrder( params );\n\tfor ( i = 0; i < params.length; i++ ) {\n\t\tp = params[ i ];\n\t\tif ( p.scalar ) {\n\t\t\tp.scalar = false;\n\t\t\tp.value = broadcastScalar( p.value, p.dtype, shape, ord );\n\t\t\tp.order = ord;\n\t\t} else {\n\t\t\tp.value = broadcast( p.value, shape ); // delegate to `broadcast` to ensure broadcast compatibility\n\t\t}\n\t\tp.ndims = shape.length;\n\t}\n\treturn params;\n}\n\n\n// MAIN //\n\n/**\n* Constructor for creating ndarrays filled with pseudorandom values drawn from a binary PRNG.\n*\n* @constructor\n* @param {Function} prng - binary pseudorandom value generator\n* @param {ArrayLikeObject<ArrayLikeObject>} idtypes - list containing a list of supported input data types for each PRNG parameter\n* @param {ArrayLikeObject} odtypes - list of supported output data types\n* @param {Object} policies - policies\n* @param {string} policies.output - output data type policy\n* @param {Object} [options] - function options\n* @param {string} [options.order] - default memory layout\n* @throws {TypeError} first argument must be a function\n* @throws {TypeError} second argument must be an array containing arrays of supported data types\n* @throws {TypeError} third argument must be an array of supported data types\n* @throws {TypeError} fourth argument must be an object having supported policies\n* @throws {TypeError} options argument must be an object\n* @throws {TypeError} must provide valid options\n* @returns {Random} instance\n*\n* @example\n* var dtypes = require( '@stdlib/ndarray-dtypes' );\n* var uniform = require( '@stdlib/random-base-uniform' );\n*\n* var idt = dtypes( 'real_and_generic' );\n* var odt = dtypes( 'real_floating_point_and_generic' );\n*\n* var policies = {\n*     'output': 'real_floating_point_and_generic'\n* };\n* var options = {\n*     'order': 'row-major'\n* };\n*\n* var rand = new Random( uniform, [ idt, idt ], odt, policies, options );\n*\n* var v = rand.generate( [ 2, 2 ], 0.0, 1.0 );\n* // returns <ndarray>\n*\n* @example\n* var dtypes = require( '@stdlib/ndarray-dtypes' );\n* var ndzeros = require( '@stdlib/ndarray-zeros' );\n* var uniform = require( '@stdlib/random-base-uniform' );\n*\n* var idt = dtypes( 'real_and_generic' );\n* var odt = dtypes( 'real_floating_point_and_generic' );\n*\n* var policies = {\n*     'output': 'real_floating_point_and_generic'\n* };\n* var options = {\n*     'order': 'row-major'\n* };\n*\n* var rand = new Random( uniform, [ idt, idt ], odt, policies, options );\n*\n* var out = ndzeros( [ 2, 2 ] );\n* var v = rand.assign( 0.0, 1.0, out );\n* // returns <ndarray>\n*\n* var bool = ( v === out );\n* // returns true\n*/\nfunction Random( prng, idtypes, odtypes, policies, options ) {\n\tvar opts;\n\tvar dt;\n\tvar i;\n\tif ( !( this instanceof Random ) ) {\n\t\tif ( arguments.length < 5 ) {\n\t\t\treturn new Random( prng, idtypes, odtypes, policies );\n\t\t}\n\t\treturn new Random( prng, idtypes, odtypes, policies, options );\n\t}\n\tif ( !isFunction( prng ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a function. Value: `%s`.', prng ) );\n\t}\n\tif ( !isCollection( idtypes ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Second argument must be an array-like object. Value: `%s`.', idtypes ) );\n\t}\n\tidtypes = copy( idtypes );\n\tfor ( i = 0; i < idtypes.length; i++ ) {\n\t\tdt = idtypes[ i ];\n\t\tif (\n\t\t\t!isCollection( dt ) ||\n\t\t\tdt.length < 1 ||\n\t\t\t!everyBy( dt, isDataType )\n\t\t) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Second argument must contain arrays of data types. Value: `%s`.', idtypes ) );\n\t\t}\n\t\tidtypes[ i ] = dtypes2strings( dt );\n\t}\n\tif (\n\t\t!isCollection( odtypes ) ||\n\t\todtypes.length < 1 ||\n\t\t!everyBy( odtypes, isDataType )\n\t) {\n\t\tthrow new TypeError( format( 'invalid argument. Third argument must be an array of data types. Value: `%s`.', odtypes ) );\n\t}\n\todtypes = dtypes2strings( odtypes );\n\n\tif ( !isObject( policies ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Fourth argument must be an object. Value: `%s`.', policies ) );\n\t}\n\tif ( !isOutputDataTypePolicy( policies.output ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Fourth argument must be an object having a supported output data type policy. Value: `%s`.', policies.output ) );\n\t}\n\topts = {\n\t\t'order': defaults.get( 'order' )\n\t};\n\tif ( arguments.length > 4 ) {\n\t\tif ( !isPlainObject( options ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Options argument must be an object. Value: `%s`.', options ) );\n\t\t}\n\t\tif ( hasOwnProp( options, 'order' ) ) {\n\t\t\topts.order = options.order;\n\t\t\tif ( !isOrder( opts.order ) ) {\n\t\t\t\tthrow new TypeError( format( 'invalid option. `%s` option must be a valid memory layout. Option: `%s`.', 'order', opts.order ) );\n\t\t\t}\n\t\t}\n\t}\n\tthis._prng = prng;\n\tthis._idtypes = idtypes;\n\tthis._odtypes = odtypes;\n\tthis._policies = {\n\t\t'output': policies.output\n\t};\n\tthis._opts = opts;\n\treturn this;\n}\n\n/**\n* Returns an ndarray filled with pseudorandom values drawn from a binary PRNG.\n*\n* @name generate\n* @memberof Random.prototype\n* @type {Function}\n* @param {NonNegativeIntegerArray} shape - output shape\n* @param {(ndarrayLike|*)} param1 - first PRNG parameter\n* @param {(ndarrayLike|*)} param2 - second PRNG parameter\n* @param {Options} [options] - function options\n* @param {*} [options.dtype] - output ndarray data type\n* @param {string} [options.order] - memory layout (either row-major or column-major)\n* @param {string} [options.mode] - specifies how to handle indices which exceed ndarray dimensions\n* @param {ArrayLikeObject<string>} [options.submode] - specifies how to handle subscripts which exceed ndarray dimensions on a per dimension basis\n* @param {boolean} [options.readonly] - boolean indicating whether an ndarray should be read-only\n* @throws {TypeError} first argument must be a valid shape\n* @throws {TypeError} must provide valid PRNG parameters\n* @throws {TypeError} PRNG parameters and the desired shape must be broadcast compatible\n* @throws {TypeError} options argument must be an object\n* @throws {TypeError} must provide valid options\n* @returns {ndarray} output ndarray\n*\n* @example\n* var dtypes = require( '@stdlib/ndarray-dtypes' );\n* var uniform = require( '@stdlib/random-base-uniform' );\n*\n* var idt = dtypes( 'real_and_generic' );\n* var odt = dtypes( 'real_floating_point_and_generic' );\n*\n* var policies = {\n*     'output': 'real_floating_point_and_generic'\n* };\n* var options = {\n*     'order': 'row-major'\n* };\n*\n* var rand = new Random( uniform, [ idt, idt ], odt, policies, options );\n*\n* var v = rand.generate( [ 2, 2 ], 0.0, 1.0 );\n* // returns <ndarray>\n*/\nsetReadOnly( Random.prototype, 'generate', function generate( shape, param1, param2, options ) {\n\tvar params;\n\tvar prng;\n\tvar opts;\n\tvar buf;\n\tvar err;\n\tvar len;\n\tvar ord;\n\tvar FLG;\n\tvar out;\n\tvar set;\n\tvar dt;\n\tvar st;\n\tvar p1;\n\tvar p2;\n\tvar i;\n\n\tif ( !isNonNegativeIntegerArray( shape ) && !isEmptyCollection( shape ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be an array-like object containing nonnegative integers. Value: `%s`.', shape ) );\n\t}\n\topts = {};\n\tif ( arguments.length > 3 ) {\n\t\terr = validate( opts, this._odtypes, options );\n\t\tif ( err ) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\tparams = initialScan( [ param1, param2 ] );\n\tfor ( i = 0; i < params.length; i++ ) {\n\t\tdt = params[ i ].dtype;\n\t\tif ( !contains( this._idtypes[ i ], resolveStr( dt ) ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. %s argument must have one of the following data types: \"%s\". Data type: `%s`.', ORDINALS[ i+1 ], join( this._idtypes[ i ], '\", \"' ), dt ) );\n\t\t}\n\t}\n\tFLG = isScalarCompatible( params );\n\tif ( FLG ) {\n\t\tparams = convertToScalars( params );\n\t} else {\n\t\tparams = broadcastParameters( shape, params );\n\t}\n\tp1 = params[ 0 ];\n\tp2 = params[ 1 ];\n\tprng = this._prng;\n\tdt = opts.dtype || binaryOutputDataType( p1.dtype, p2.dtype, this._policies.output ); // eslint-disable-line max-len\n\tif ( opts.order ) {\n\t\tord = opts.order;\n\t} else if ( FLG ) {\n\t\tord = this._opts.order;\n\t} else {\n\t\t// If we don't have any explicit order info, use the order of the first parameter, as no clear rationale for choosing the order of one parameter over another:\n\t\tord = p1.order;\n\t}\n\t// Handles special cases involving (1) zero-dimensional output ndarrays and (2) shapes having at least one dimension of size zero...\n\tlen = numel( shape );\n\tif ( len === 0 ) {\n\t\t// Check for a zero-dimensional shape...\n\t\tif ( shape.length === 0 ) {\n\t\t\t// If the output array is a zero-dimensional ndarray, we generate a single random variate...\n\t\t\tbuf = buffer( dt, 1 );\n\t\t\tif ( isAccessorArray( buf ) ) {\n\t\t\t\tset = accessorSetter( dt );\n\t\t\t} else {\n\t\t\t\tset = setter( dt );\n\t\t\t}\n\t\t\tset( buf, 0, prng( p1.value, p2.value ) );\n\t\t\tst = [ 0 ];\n\t\t} else {\n\t\t\t// If the output array has one or more dimensions of size zero, we avoid allocating any memory, and instead return an empty ndarray...\n\t\t\tbuf = buffer( dt, len );\n\t\t\tst = shape2strides( shape, ord );\n\t\t}\n\t\treturn new ndarray( dt, buf, shape, st, 0, ord, opts );\n\t}\n\t// If provided scalar PRNG parameters, we can simply fill a linear buffer with pseudorandom values (as all pseudorandom values are drawn from the same PRNG) and then wrap as an ndarray...\n\tif ( FLG ) {\n\t\tif ( isEqualDataType( dt, 'generic' ) ) {\n\t\t\tbuf = filledBy( len, wrapper );\n\t\t} else {\n\t\t\tbuf = buffer( dt, len );\n\t\t\tnullaryStrided( [ buf ], [ len ], [ 1 ], wrapper );\n\t\t}\n\t\tst = shape2strides( shape, ord );\n\t\treturn new ndarray( dt, buf, shape, st, 0, ord, opts );\n\t}\n\t// We've been provided ndarrays, so we need to perform element-wise iteration...\n\n\t// Allocate a data buffer:\n\tbuf = buffer( dt, len );\n\n\t// Initialize the output array:\n\tst = shape2strides( shape, ord );\n\tout = new ndarray( dt, buf, shape, st, 0, ord, opts );\n\n\t// Fill the output array with pseudorandom values:\n\tbinary( [ p1.value, p2.value, out ], prng );\n\n\treturn out;\n\n\t/**\n\t* Applies parameters to a pseudorandom number generator function.\n\t*\n\t* @private\n\t* @returns {(number|ComplexLike)} pseudorandom number\n\t*/\n\tfunction wrapper() {\n\t\treturn prng( p1.value, p2.value );\n\t}\n});\n\n/**\n* Fills an ndarray with pseudorandom values drawn from a binary PRNG.\n*\n* @name assign\n* @memberof Random.prototype\n* @type {Function}\n* @param {(ndarrayLike|*)} param1 - first PRNG parameter\n* @param {(ndarrayLike|*)} param2 - second PRNG parameter\n* @param {ndarrayLike} out - output ndarray\n* @throws {TypeError} third argument must be an ndarray\n* @throws {TypeError} must provide valid PRNG parameters\n* @throws {TypeError} PRNG parameters and the output ndarray must be broadcast compatible\n* @throws {Error} cannot write to a read-only ndarray\n* @returns {ndarray} output ndarray\n*\n* @example\n* var dtypes = require( '@stdlib/ndarray-dtypes' );\n* var ndzeros = require( '@stdlib/ndarray-zeros' );\n* var uniform = require( '@stdlib/random-base-uniform' );\n*\n* var idt = dtypes( 'real_and_generic' );\n* var odt = dtypes( 'real_floating_point_and_generic' );\n*\n* var policies = {\n*     'output': 'real_floating_point_and_generic'\n* };\n* var options = {\n*     'order': 'row-major'\n* };\n*\n* var rand = new Random( uniform, [ idt, idt ], odt, policies, options );\n*\n* var out = ndzeros( [ 2, 2 ] );\n* var v = rand.assign( 0.0, 1.0, out );\n* // returns <ndarray>\n*\n* var bool = ( v === out );\n* // returns true\n*/\nsetReadOnly( Random.prototype, 'assign', function assign( param1, param2, out ) {\n\tvar params;\n\tvar pdt;\n\tvar odt;\n\tvar ord;\n\tvar sh;\n\tvar p;\n\tvar i;\n\n\tif ( !isndarrayLike( out ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Third argument must be an ndarray-like object. Value: `%s`.', out ) );\n\t}\n\tif ( isReadOnly( out ) ) {\n\t\tthrow new Error( 'invalid argument. The output ndarray must be writable. Cannot write to a read-only ndarray.' );\n\t}\n\tsh = getShape( out );\n\tord = getOrder( out );\n\todt = getDType( out );\n\tif ( !contains( this._odtypes, resolveStr( odt ) ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. %s argument must have one of the following data types: \"%s\". Data type: `%s`.', ORDINALS[ 2 ], join( this._odtypes, '\", \"' ), odt ) );\n\t}\n\tparams = [ param1, param2 ];\n\tfor ( i = 0; i < params.length; i++ ) {\n\t\tp = params[ i ];\n\n\t\t// Check whether we've been provided a scalar PRNG parameter...\n\t\tif ( isNumber( p ) ) {\n\t\t\t// Wrap the scalar in a broadcasted ndarray:\n\t\t\tpdt = 'float64';\n\t\t\tp = broadcastScalar( p, pdt, sh, ord );\n\t\t} else if ( isComplexLike( p ) ) {\n\t\t\tif ( p.byteLength === 8 ) {\n\t\t\t\tpdt = 'complex64';\n\t\t\t} else {\n\t\t\t\tpdt = 'complex128';\n\t\t\t}\n\t\t\t// Wrap the scalar in a broadcasted ndarray:\n\t\t\tp = broadcastScalar( p, pdt, sh, ord );\n\t\t} else if ( isndarrayLike( p ) ) {\n\t\t\t// Broadcast the PRNG parameter to the desired shape:\n\t\t\tpdt = getDType( p );\n\t\t\tp = broadcast( p, sh ); // delegate to `broadcast` to ensure broadcast compatibility\n\t\t} else {\n\t\t\t// Wrap the scalar in a broadcasted ndarray:\n\t\t\tpdt = 'generic';\n\t\t\tp = broadcastScalar( p, pdt, sh, ord );\n\t\t}\n\t\tif ( !contains( this._idtypes[ i ], resolveStr( pdt ) ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. %s argument must have one of the following data types: \"%s\". Data type: `%s`.', ORDINALS[ i ], join( this._idtypes[ i ], '\", \"' ), pdt ) );\n\t\t}\n\t\tparams[ i ] = p;\n\t}\n\t// Fill the output array with pseudorandom values:\n\tparams.push( out );\n\tbinary( params, this._prng );\n\n\treturn out;\n});\n\n\n// EXPORTS //\n\nmodule.exports = Random;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Constructor for creating ndarrays filled with pseudorandom values drawn from a binary PRNG.\n*\n* @module @stdlib/random-tools-binary\n*\n* @example\n* var dtypes = require( '@stdlib/ndarray-dtypes' );\n* var uniform = require( '@stdlib/random-base-uniform' );\n* var Random = require( '@stdlib/random-tools-binary' );\n*\n* var idt = dtypes( 'real_and_generic' );\n* var odt = dtypes( 'real_floating_point_and_generic' );\n*\n* var policies = {\n*     'output': 'real_floating_point_and_generic'\n* };\n* var options = {\n*     'order': 'row-major'\n* };\n*\n* var rand = new Random( uniform, [ idt, idt ], odt, policies, options );\n*\n* var v = rand.generate( [ 2, 2 ], 0.0, 1.0 );\n* // returns <ndarray>\n*\n* @example\n* var dtypes = require( '@stdlib/ndarray-dtypes' );\n* var ndzeros = require( '@stdlib/ndarray-zeros' );\n* var uniform = require( '@stdlib/random-base-uniform' );\n* var Random = require( '@stdlib/random-tools-binary' );\n*\n* var idt = dtypes( 'real_and_generic' );\n* var odt = dtypes( 'real_floating_point_and_generic' );\n*\n* var policies = {\n*     'output': 'real_floating_point_and_generic'\n* };\n* var options = {\n*     'order': 'row-major'\n* };\n*\n* var rand = new Random( uniform, [ idt, idt ], odt, policies, options );\n*\n* var out = ndzeros( [ 2, 2 ] );\n* var v = rand.assign( 0.0, 1.0, out );\n* // returns <ndarray>\n*\n* var bool = ( v === out );\n* // returns true\n*/\n\n// MODULES //\n\nvar main = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "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",
  "names": ["require_validate", "__commonJSMin", "exports", "module", "isObject", "hasOwnProp", "contains", "join", "resolveStr", "format", "validate", "opts", "dtypes", "options", "require_main", "__commonJSMin", "exports", "module", "setReadOnly", "isNonNegativeIntegerArray", "isEmptyCollection", "isndarrayLike", "isNumber", "isFunction", "isComplexLike", "isPlainObject", "isObject", "isCollection", "isDataType", "isEqualDataType", "isOutputDataTypePolicy", "isReadOnly", "isOrder", "hasOwnProp", "contains", "filledBy", "everyBy", "join", "copy", "nullaryStrided", "binary", "broadcast", "broadcastScalar", "shape2strides", "dtypes2strings", "resolveStr", "binaryOutputDataType", "numel", "buffer", "getShape", "getDType", "getOrder", "ndims", "ndarray", "defaults", "isAccessorArray", "accessorSetter", "setter", "format", "validate", "ORDINALS", "initialScan", "params", "out", "p", "o", "i", "isScalarCompatible", "count", "convertToScalars", "resolveOrder", "broadcastParameters", "shape", "ord", "Random", "prng", "idtypes", "odtypes", "policies", "options", "opts", "dt", "param1", "param2", "buf", "err", "len", "FLG", "set", "st", "p1", "p2", "wrapper", "pdt", "odt", "sh", "main"]
}
