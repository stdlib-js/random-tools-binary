{"version":3,"file":"index.mjs","sources":["../lib/main.js","../lib/validate.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-restricted-syntax, no-invalid-this */\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property';\nimport { primitives as isNonNegativeIntegerArray } from '@stdlib/assert-is-nonnegative-integer-array';\nimport isEmptyCollection from '@stdlib/assert-is-empty-collection';\nimport isndarrayLike from '@stdlib/assert-is-ndarray-like';\nimport { isPrimitive as isNumber } from '@stdlib/assert-is-number';\nimport isFunction from '@stdlib/assert-is-function';\nimport isComplexLike from '@stdlib/assert-is-complex-like';\nimport isPlainObject from '@stdlib/assert-is-plain-object';\nimport isObject from '@stdlib/assert-is-object';\nimport isCollection from '@stdlib/assert-is-collection';\nimport isDataType from '@stdlib/ndarray-base-assert-is-data-type';\nimport isEqualDataType from '@stdlib/ndarray-base-assert-is-equal-data-type';\nimport isOutputDataTypePolicy from '@stdlib/ndarray-base-assert-is-output-data-type-policy';\nimport isReadOnly from '@stdlib/ndarray-base-assert-is-read-only';\nimport isOrder from '@stdlib/ndarray-base-assert-is-order';\nimport hasOwnProp from '@stdlib/assert-has-own-property';\nimport contains from '@stdlib/array-base-assert-contains';\nimport filledBy from '@stdlib/array-base-filled-by';\nimport everyBy from '@stdlib/array-base-every-by';\nimport join from '@stdlib/array-base-join';\nimport copy from '@stdlib/array-base-copy';\nimport nullaryStrided from '@stdlib/strided-base-nullary';\nimport binary from '@stdlib/ndarray-base-binary';\nimport broadcast from '@stdlib/ndarray-base-maybe-broadcast-array';\nimport broadcastScalar from '@stdlib/ndarray-base-broadcast-scalar';\nimport shape2strides from '@stdlib/ndarray-base-shape2strides';\nimport dtypes2strings from '@stdlib/ndarray-base-dtypes2strings';\nimport resolveStr from '@stdlib/ndarray-base-dtype-resolve-str';\nimport binaryOutputDataType from '@stdlib/ndarray-base-binary-output-dtype';\nimport numel from '@stdlib/ndarray-base-numel';\nimport buffer from '@stdlib/ndarray-base-buffer';\nimport getShape from '@stdlib/ndarray-shape';\nimport getDType from '@stdlib/ndarray-dtype';\nimport getOrder from '@stdlib/ndarray-order';\nimport ndims from '@stdlib/ndarray-ndims';\nimport ndarray from '@stdlib/ndarray-ctor';\nimport defaults from '@stdlib/ndarray-defaults';\nimport isAccessorArray from '@stdlib/array-base-assert-is-accessor-array';\nimport accessorSetter from '@stdlib/array-base-accessor-setter';\nimport setter from '@stdlib/array-base-setter';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport validate from './validate.js';\n\n\n// VARIABLES //\n\nvar ORDINALS = [ 'First', 'Second', 'Third' ];\n\n\n// FUNCTIONS //\n\n/**\n* Performs an initial scan of a list of parameters.\n*\n* @private\n* @param {Array} params - list of parameters\n* @returns {Array} scan results\n*/\nfunction initialScan( params ) {\n\tvar out;\n\tvar p;\n\tvar o;\n\tvar i;\n\n\tout = [];\n\tfor ( i = 0; i < params.length; i++ ) {\n\t\tp = params[ i ];\n\t\to = {\n\t\t\t'scalar': true,\n\t\t\t'value': p,\n\t\t\t'dtype': '',\n\t\t\t'ndims': 0,\n\t\t\t'order': ''\n\t\t};\n\t\tif ( isNumber( p ) ) {\n\t\t\to.dtype = 'float64';\n\t\t} else if ( isComplexLike( p ) ) {\n\t\t\tif ( p.byteLength === 8 ) {\n\t\t\t\to.dtype = 'complex64';\n\t\t\t} else {\n\t\t\t\to.dtype = 'complex128';\n\t\t\t}\n\t\t} else if ( isndarrayLike( p ) ) {\n\t\t\to.scalar = false;\n\t\t\to.dtype = resolveStr( getDType( p ) );\n\t\t\to.ndims = ndims( p );\n\t\t\to.order = getOrder( p );\n\t\t} else {\n\t\t\to.dtype = 'generic';\n\t\t}\n\t\tout.push( o );\n\t}\n\treturn out;\n}\n\n/**\n* Checks whether all parameters are scalar compatible.\n*\n* ## Notes\n*\n* -   A parameter is scalar compatible if, and only if, the parameter value is either a zero-dimensional ndarray or already a scalar value.\n*\n* @private\n* @param {Array<Object>} params - list of parameter objects\n* @returns {boolean} boolean indicating whether all parameters are scalar compatible\n*/\nfunction isScalarCompatible( params ) {\n\tvar count;\n\tvar p;\n\tvar i;\n\n\tcount = 0;\n\tfor ( i = 0; i < params.length; i++ ) {\n\t\tp = params[ i ];\n\t\tif ( p.scalar || p.ndims === 0 ) {\n\t\t\tcount += 1;\n\t\t}\n\t}\n\treturn ( count === params.length );\n}\n\n/**\n* Converts a list of parameters to scalar values.\n*\n* ## Notes\n*\n* -   The function **mutates** the input array by updating parameter objects which do not already correspond to scalar parameter values.\n*\n* @private\n* @param {Array<Object>} params - list of parameter objects\n* @returns {Array<Object>} updated list\n*/\nfunction convertToScalars( params ) {\n\tvar p;\n\tvar i;\n\n\tfor ( i = 0; i < params.length; i++ ) {\n\t\tp = params[ i ];\n\t\tif ( p.scalar === false ) {\n\t\t\tp.scalar = true;\n\t\t\tp.value = p.value.get();\n\t\t\tp.ndims = 0;\n\t\t\tp.order = '';\n\t\t}\n\t}\n\treturn params;\n}\n\n/**\n* Resolves a common memory layout from a list of parameter objects.\n*\n* @private\n* @param {Array<Object>} params - list of parameter objects\n* @returns {string} memory layout\n*/\nfunction resolveOrder( params ) {\n\tvar p;\n\tvar i;\n\tfor ( i = 0; i < params.length; i++ ) {\n\t\tp = params[ i ];\n\n\t\t// For a binary parameter function, we simply return the layout of the first parameter having a layout, as there is no clear rationale for picking the layout of one parameter over another and picking the first one we find is as good a rationale as any other...\n\t\tif ( p.scalar === false ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn p.order;\n}\n\n/**\n* Broadcasts parameter values to an ndarray having a specified shape.\n*\n* ## Notes\n*\n* -   The function **mutates** the input array.\n*\n* @private\n* @param {NonNegativeIntegerArray} shape - array shape\n* @param {Array<Object>} params - list of parameter objects\n* @returns {Array<Object>} updated list\n*/\nfunction broadcastParameters( shape, params ) {\n\tvar ord;\n\tvar p;\n\tvar i;\n\n\tord = resolveOrder( params );\n\tfor ( i = 0; i < params.length; i++ ) {\n\t\tp = params[ i ];\n\t\tif ( p.scalar ) {\n\t\t\tp.scalar = false;\n\t\t\tp.value = broadcastScalar( p.value, p.dtype, shape, ord );\n\t\t\tp.order = ord;\n\t\t} else {\n\t\t\tp.value = broadcast( p.value, shape ); // delegate to `broadcast` to ensure broadcast compatibility\n\t\t}\n\t\tp.ndims = shape.length;\n\t}\n\treturn params;\n}\n\n\n// MAIN //\n\n/**\n* Constructor for creating ndarrays filled with pseudorandom values drawn from a binary PRNG.\n*\n* @constructor\n* @param {Function} prng - binary pseudorandom value generator\n* @param {ArrayLikeObject<ArrayLikeObject>} idtypes - list containing a list of supported input data types for each PRNG parameter\n* @param {ArrayLikeObject} odtypes - list of supported output data types\n* @param {Object} policies - policies\n* @param {string} policies.output - output data type policy\n* @param {Object} [options] - function options\n* @param {string} [options.order] - default memory layout\n* @throws {TypeError} first argument must be a function\n* @throws {TypeError} second argument must be an array containing arrays of supported data types\n* @throws {TypeError} third argument must be an array of supported data types\n* @throws {TypeError} fourth argument must be an object having supported policies\n* @throws {TypeError} options argument must be an object\n* @throws {TypeError} must provide valid options\n* @returns {Random} instance\n*\n* @example\n* import dtypes from '@stdlib/ndarray-dtypes';\n* import uniform from '@stdlib/random-base-uniform';\n*\n* var idt = dtypes( 'real_and_generic' );\n* var odt = dtypes( 'real_floating_point_and_generic' );\n*\n* var policies = {\n*     'output': 'real_floating_point_and_generic'\n* };\n* var options = {\n*     'order': 'row-major'\n* };\n*\n* var rand = new Random( uniform, [ idt, idt ], odt, policies, options );\n*\n* var v = rand.generate( [ 2, 2 ], 0.0, 1.0 );\n* // returns <ndarray>\n*\n* @example\n* import dtypes from '@stdlib/ndarray-dtypes';\n* import ndzeros from '@stdlib/ndarray-zeros';\n* import uniform from '@stdlib/random-base-uniform';\n*\n* var idt = dtypes( 'real_and_generic' );\n* var odt = dtypes( 'real_floating_point_and_generic' );\n*\n* var policies = {\n*     'output': 'real_floating_point_and_generic'\n* };\n* var options = {\n*     'order': 'row-major'\n* };\n*\n* var rand = new Random( uniform, [ idt, idt ], odt, policies, options );\n*\n* var out = ndzeros( [ 2, 2 ] );\n* var v = rand.assign( 0.0, 1.0, out );\n* // returns <ndarray>\n*\n* var bool = ( v === out );\n* // returns true\n*/\nfunction Random( prng, idtypes, odtypes, policies, options ) {\n\tvar opts;\n\tvar dt;\n\tvar i;\n\tif ( !( this instanceof Random ) ) {\n\t\tif ( arguments.length < 5 ) {\n\t\t\treturn new Random( prng, idtypes, odtypes, policies );\n\t\t}\n\t\treturn new Random( prng, idtypes, odtypes, policies, options );\n\t}\n\tif ( !isFunction( prng ) ) {\n\t\tthrow new TypeError( format( 'null3c', prng ) );\n\t}\n\tif ( !isCollection( idtypes ) ) {\n\t\tthrow new TypeError( format( 'null2y', idtypes ) );\n\t}\n\tidtypes = copy( idtypes );\n\tfor ( i = 0; i < idtypes.length; i++ ) {\n\t\tdt = idtypes[ i ];\n\t\tif (\n\t\t\t!isCollection( dt ) ||\n\t\t\tdt.length < 1 ||\n\t\t\t!everyBy( dt, isDataType )\n\t\t) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Second argument must contain arrays of data types. Value: `%s`.', idtypes ) );\n\t\t}\n\t\tidtypes[ i ] = dtypes2strings( dt );\n\t}\n\tif (\n\t\t!isCollection( odtypes ) ||\n\t\todtypes.length < 1 ||\n\t\t!everyBy( odtypes, isDataType )\n\t) {\n\t\tthrow new TypeError( format( 'invalid argument. Third argument must be an array of data types. Value: `%s`.', odtypes ) );\n\t}\n\todtypes = dtypes2strings( odtypes );\n\n\tif ( !isObject( policies ) ) {\n\t\tthrow new TypeError( format( 'null43', policies ) );\n\t}\n\tif ( !isOutputDataTypePolicy( policies.output ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Fourth argument must be an object having a supported output data type policy. Value: `%s`.', policies.output ) );\n\t}\n\topts = {\n\t\t'order': defaults.get( 'order' )\n\t};\n\tif ( arguments.length > 4 ) {\n\t\tif ( !isPlainObject( options ) ) {\n\t\t\tthrow new TypeError( format( 'null2V', options ) );\n\t\t}\n\t\tif ( hasOwnProp( options, 'order' ) ) {\n\t\t\topts.order = options.order;\n\t\t\tif ( !isOrder( opts.order ) ) {\n\t\t\t\tthrow new TypeError( format( 'invalid option. `%s` option must be a valid memory layout. Option: `%s`.', 'order', opts.order ) );\n\t\t\t}\n\t\t}\n\t}\n\tthis._prng = prng;\n\tthis._idtypes = idtypes;\n\tthis._odtypes = odtypes;\n\tthis._policies = {\n\t\t'output': policies.output\n\t};\n\tthis._opts = opts;\n\treturn this;\n}\n\n/**\n* Returns an ndarray filled with pseudorandom values drawn from a binary PRNG.\n*\n* @name generate\n* @memberof Random.prototype\n* @type {Function}\n* @param {NonNegativeIntegerArray} shape - output shape\n* @param {(ndarrayLike|*)} param1 - first PRNG parameter\n* @param {(ndarrayLike|*)} param2 - second PRNG parameter\n* @param {Options} [options] - function options\n* @param {*} [options.dtype] - output ndarray data type\n* @param {string} [options.order] - memory layout (either row-major or column-major)\n* @param {string} [options.mode] - specifies how to handle indices which exceed ndarray dimensions\n* @param {ArrayLikeObject<string>} [options.submode] - specifies how to handle subscripts which exceed ndarray dimensions on a per dimension basis\n* @param {boolean} [options.readonly] - boolean indicating whether an ndarray should be read-only\n* @throws {TypeError} first argument must be a valid shape\n* @throws {TypeError} must provide valid PRNG parameters\n* @throws {TypeError} PRNG parameters and the desired shape must be broadcast compatible\n* @throws {TypeError} options argument must be an object\n* @throws {TypeError} must provide valid options\n* @returns {ndarray} output ndarray\n*\n* @example\n* import dtypes from '@stdlib/ndarray-dtypes';\n* import uniform from '@stdlib/random-base-uniform';\n*\n* var idt = dtypes( 'real_and_generic' );\n* var odt = dtypes( 'real_floating_point_and_generic' );\n*\n* var policies = {\n*     'output': 'real_floating_point_and_generic'\n* };\n* var options = {\n*     'order': 'row-major'\n* };\n*\n* var rand = new Random( uniform, [ idt, idt ], odt, policies, options );\n*\n* var v = rand.generate( [ 2, 2 ], 0.0, 1.0 );\n* // returns <ndarray>\n*/\nsetReadOnly( Random.prototype, 'generate', function generate( shape, param1, param2, options ) {\n\tvar params;\n\tvar prng;\n\tvar opts;\n\tvar buf;\n\tvar err;\n\tvar len;\n\tvar ord;\n\tvar FLG;\n\tvar out;\n\tvar set;\n\tvar dt;\n\tvar st;\n\tvar p1;\n\tvar p2;\n\tvar i;\n\n\tif ( !isNonNegativeIntegerArray( shape ) && !isEmptyCollection( shape ) ) {\n\t\tthrow new TypeError( format( 'null5o', shape ) );\n\t}\n\topts = {};\n\tif ( arguments.length > 3 ) {\n\t\terr = validate( opts, this._odtypes, options );\n\t\tif ( err ) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\tparams = initialScan( [ param1, param2 ] );\n\tfor ( i = 0; i < params.length; i++ ) {\n\t\tdt = params[ i ].dtype;\n\t\tif ( !contains( this._idtypes[ i ], resolveStr( dt ) ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. %s argument must have one of the following data types: \"%s\". Data type: `%s`.', ORDINALS[ i+1 ], join( this._idtypes[ i ], '\", \"' ), dt ) );\n\t\t}\n\t}\n\tFLG = isScalarCompatible( params );\n\tif ( FLG ) {\n\t\tparams = convertToScalars( params );\n\t} else {\n\t\tparams = broadcastParameters( shape, params );\n\t}\n\tp1 = params[ 0 ];\n\tp2 = params[ 1 ];\n\tprng = this._prng;\n\tdt = opts.dtype || binaryOutputDataType( p1.dtype, p2.dtype, this._policies.output ); // eslint-disable-line max-len\n\tif ( opts.order ) {\n\t\tord = opts.order;\n\t} else if ( FLG ) {\n\t\tord = this._opts.order;\n\t} else {\n\t\t// If we don't have any explicit order info, use the order of the first parameter, as no clear rationale for choosing the order of one parameter over another:\n\t\tord = p1.order;\n\t}\n\t// Handles special cases involving (1) zero-dimensional output ndarrays and (2) shapes having at least one dimension of size zero...\n\tlen = numel( shape );\n\tif ( len === 0 ) {\n\t\t// Check for a zero-dimensional shape...\n\t\tif ( shape.length === 0 ) {\n\t\t\t// If the output array is a zero-dimensional ndarray, we generate a single random variate...\n\t\t\tbuf = buffer( dt, 1 );\n\t\t\tif ( isAccessorArray( buf ) ) {\n\t\t\t\tset = accessorSetter( dt );\n\t\t\t} else {\n\t\t\t\tset = setter( dt );\n\t\t\t}\n\t\t\tset( buf, 0, prng( p1.value, p2.value ) );\n\t\t\tst = [ 0 ];\n\t\t} else {\n\t\t\t// If the output array has one or more dimensions of size zero, we avoid allocating any memory, and instead return an empty ndarray...\n\t\t\tbuf = buffer( dt, len );\n\t\t\tst = shape2strides( shape, ord );\n\t\t}\n\t\treturn new ndarray( dt, buf, shape, st, 0, ord, opts );\n\t}\n\t// If provided scalar PRNG parameters, we can simply fill a linear buffer with pseudorandom values (as all pseudorandom values are drawn from the same PRNG) and then wrap as an ndarray...\n\tif ( FLG ) {\n\t\tif ( isEqualDataType( dt, 'generic' ) ) {\n\t\t\tbuf = filledBy( len, wrapper );\n\t\t} else {\n\t\t\tbuf = buffer( dt, len );\n\t\t\tnullaryStrided( [ buf ], [ len ], [ 1 ], wrapper );\n\t\t}\n\t\tst = shape2strides( shape, ord );\n\t\treturn new ndarray( dt, buf, shape, st, 0, ord, opts );\n\t}\n\t// We've been provided ndarrays, so we need to perform element-wise iteration...\n\n\t// Allocate a data buffer:\n\tbuf = buffer( dt, len );\n\n\t// Initialize the output array:\n\tst = shape2strides( shape, ord );\n\tout = new ndarray( dt, buf, shape, st, 0, ord, opts );\n\n\t// Fill the output array with pseudorandom values:\n\tbinary( [ p1.value, p2.value, out ], prng );\n\n\treturn out;\n\n\t/**\n\t* Applies parameters to a pseudorandom number generator function.\n\t*\n\t* @private\n\t* @returns {(number|ComplexLike)} pseudorandom number\n\t*/\n\tfunction wrapper() {\n\t\treturn prng( p1.value, p2.value );\n\t}\n});\n\n/**\n* Fills an ndarray with pseudorandom values drawn from a binary PRNG.\n*\n* @name assign\n* @memberof Random.prototype\n* @type {Function}\n* @param {(ndarrayLike|*)} param1 - first PRNG parameter\n* @param {(ndarrayLike|*)} param2 - second PRNG parameter\n* @param {ndarrayLike} out - output ndarray\n* @throws {TypeError} third argument must be an ndarray\n* @throws {TypeError} must provide valid PRNG parameters\n* @throws {TypeError} PRNG parameters and the output ndarray must be broadcast compatible\n* @throws {Error} cannot write to a read-only ndarray\n* @returns {ndarray} output ndarray\n*\n* @example\n* import dtypes from '@stdlib/ndarray-dtypes';\n* import ndzeros from '@stdlib/ndarray-zeros';\n* import uniform from '@stdlib/random-base-uniform';\n*\n* var idt = dtypes( 'real_and_generic' );\n* var odt = dtypes( 'real_floating_point_and_generic' );\n*\n* var policies = {\n*     'output': 'real_floating_point_and_generic'\n* };\n* var options = {\n*     'order': 'row-major'\n* };\n*\n* var rand = new Random( uniform, [ idt, idt ], odt, policies, options );\n*\n* var out = ndzeros( [ 2, 2 ] );\n* var v = rand.assign( 0.0, 1.0, out );\n* // returns <ndarray>\n*\n* var bool = ( v === out );\n* // returns true\n*/\nsetReadOnly( Random.prototype, 'assign', function assign( param1, param2, out ) {\n\tvar params;\n\tvar pdt;\n\tvar odt;\n\tvar ord;\n\tvar sh;\n\tvar p;\n\tvar i;\n\n\tif ( !isndarrayLike( out ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Third argument must be an ndarray-like object. Value: `%s`.', out ) );\n\t}\n\tif ( isReadOnly( out ) ) {\n\t\tthrow new Error( format('null1g') );\n\t}\n\tsh = getShape( out );\n\tord = getOrder( out );\n\todt = getDType( out );\n\tif ( !contains( this._odtypes, resolveStr( odt ) ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. %s argument must have one of the following data types: \"%s\". Data type: `%s`.', ORDINALS[ 2 ], join( this._odtypes, '\", \"' ), odt ) );\n\t}\n\tparams = [ param1, param2 ];\n\tfor ( i = 0; i < params.length; i++ ) {\n\t\tp = params[ i ];\n\n\t\t// Check whether we've been provided a scalar PRNG parameter...\n\t\tif ( isNumber( p ) ) {\n\t\t\t// Wrap the scalar in a broadcasted ndarray:\n\t\t\tpdt = 'float64';\n\t\t\tp = broadcastScalar( p, pdt, sh, ord );\n\t\t} else if ( isComplexLike( p ) ) {\n\t\t\tif ( p.byteLength === 8 ) {\n\t\t\t\tpdt = 'complex64';\n\t\t\t} else {\n\t\t\t\tpdt = 'complex128';\n\t\t\t}\n\t\t\t// Wrap the scalar in a broadcasted ndarray:\n\t\t\tp = broadcastScalar( p, pdt, sh, ord );\n\t\t} else if ( isndarrayLike( p ) ) {\n\t\t\t// Broadcast the PRNG parameter to the desired shape:\n\t\t\tpdt = getDType( p );\n\t\t\tp = broadcast( p, sh ); // delegate to `broadcast` to ensure broadcast compatibility\n\t\t} else {\n\t\t\t// Wrap the scalar in a broadcasted ndarray:\n\t\t\tpdt = 'generic';\n\t\t\tp = broadcastScalar( p, pdt, sh, ord );\n\t\t}\n\t\tif ( !contains( this._idtypes[ i ], resolveStr( pdt ) ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. %s argument must have one of the following data types: \"%s\". Data type: `%s`.', ORDINALS[ i ], join( this._idtypes[ i ], '\", \"' ), pdt ) );\n\t\t}\n\t\tparams[ i ] = p;\n\t}\n\t// Fill the output array with pseudorandom values:\n\tparams.push( out );\n\tbinary( params, this._prng );\n\n\treturn out;\n});\n\n\n// EXPORTS //\n\nexport default Random;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isObject from '@stdlib/assert-is-plain-object';\nimport hasOwnProp from '@stdlib/assert-has-own-property';\nimport contains from '@stdlib/array-base-assert-contains';\nimport join from '@stdlib/array-base-join';\nimport resolveStr from '@stdlib/ndarray-base-dtype-resolve-str';\nimport format from '@stdlib/error-tools-fmtprodmsg';\n\n\n// MAIN //\n\n/**\n* Validates function options.\n*\n* @private\n* @param {Object} opts - destination object\n* @param {Array<string>} dtypes - list of supported output data types\n* @param {Options} options - function options\n* @param {*} [options.dtype] - array data type\n* @param {string} [options.order] - memory layout (either row-major or column-major)\n* @param {string} [options.mode] - specifies how to handle indices which exceed array dimensions\n* @param {ArrayLikeObject<string>} [options.submode] - specifies how to handle subscripts which exceed array dimensions on a per dimension basis\n* @param {boolean} [options.readonly] - boolean indicating whether an array should be read-only\n* @returns {(Error|null)} null or an error object\n*\n* @example\n* var opts = {};\n* var dtypes = [ 'float64', 'float32', 'generic' ];\n*\n* var options = {\n*     'dtype': 'float64'\n* };\n* var err = validate( opts, dtypes, options );\n* if ( err ) {\n*     throw err;\n* }\n*/\nfunction validate( opts, dtypes, options ) {\n\tif ( !isObject( options ) ) {\n\t\treturn new TypeError( format( 'null2V', options ) );\n\t}\n\tif ( hasOwnProp( options, 'dtype' ) ) {\n\t\topts.dtype = resolveStr( options.dtype );\n\t\tif ( !contains( dtypes, opts.dtype ) ) {\n\t\t\treturn new TypeError( format( 'null4S', 'dtype', join( dtypes, '\", \"' ), options.dtype ) );\n\t\t}\n\t}\n\t// Pass-through options...\n\tif ( hasOwnProp( options, 'order' ) ) {\n\t\topts.order = options.order;\n\t}\n\tif ( hasOwnProp( options, 'mode' ) ) {\n\t\topts.mode = options.mode;\n\t}\n\tif ( hasOwnProp( options, 'submode' ) ) {\n\t\topts.submode = options.submode;\n\t}\n\tif ( hasOwnProp( options, 'readonly' ) ) {\n\t\topts.readonly = options.readonly;\n\t}\n\treturn null;\n}\n\n\n// EXPORTS //\n\nexport default validate;\n"],"names":["ORDINALS","Random","prng","idtypes","odtypes","policies","options","opts","dt","i","this","arguments","length","isFunction","TypeError","format","isCollection","copy","everyBy","isDataType","dtypes2strings","isObject","isOutputDataTypePolicy","output","order","defaults","get","isPlainObject","hasOwnProp","isOrder","_prng","_idtypes","_odtypes","_policies","_opts","setReadOnly","prototype","shape","param1","param2","params","buf","err","len","ord","FLG","out","st","p1","p2","isNonNegativeIntegerArray","isEmptyCollection","dtypes","dtype","resolveStr","contains","join","mode","submode","readonly","validate","p","o","scalar","value","ndims","isNumber","isComplexLike","byteLength","isndarrayLike","getDType","getOrder","push","initialScan","count","isScalarCompatible","convertToScalars","resolveOrder","broadcastScalar","broadcast","broadcastParameters","binaryOutputDataType","numel","buffer","isAccessorArray","accessorSetter","setter","shape2strides","ndarray","isEqualDataType","filledBy","wrapper","nullaryStrided","binary","pdt","odt","sh","isReadOnly","Error","getShape"],"mappings":"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"}